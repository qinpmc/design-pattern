## 闭包

### 闭包概念
 闭包是一个函数在创建时，允许该函数访问并操作该函数之外的变量时所创建的作用域。  
 引自：《Javascript Ninja》 p86    
 
 示例：闭包.html
 //闭包作用--封装变量
 // 闭包作用---延续局部变量寿命
 
### 闭包与内存管理

局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包所形成的环境中，那么这个局部变量就能一直生存下去。    
如果将来要回收这些变量，可以手动地将这些变量设为null。

**闭包和内存泄漏**
使用闭包比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，有可能造成内存泄漏。在IE浏览器中，由于BOM和DOM中的对象  
是使用C++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略，如果两个对象间形成了循环引用，那么两个对象都无法被  
回收，从而造成内存泄漏。   


### 函数节流和防抖
1. 防抖：设定一个时间间隔，当某个频繁触发的函数执行一次后，在这个时间间隔内不会再次被触发，如果在此期间尝试触发这个函数，则时间间隔会重新开始计算。

2. 节流：设定一个时间间隔，某个频繁触发的函数，在这个时间间隔内只会执行一次。也就是说，这个频繁触发的函数会以一个固定的周期执行。

**防抖常用场景**
防抖的应用场景是连续的事件响应我们只触发一次回调，比如下面的场景：

- resize/scroll 触发统计事件
- 文本输入验证，不用用户输一个文字调用一次ajax请求，随着用户的输入验证一次就可以

**节流常用场景**
节流是个很公平的函数，隔一段时间就来触发回调,比如下面的场景:

- DOM 元素的拖拽功能实现（mousemove）
- 计算鼠标移动的距离（mousemove）
- 搜索联想（keyup）
- Canvas 模拟画板功能（mousemove）
- 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）
- 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了debounce后，只有用户停止滚动后，才会判断是否到了页面底部；
 如果是throttle的话，只要页面滚动就会间隔一段时间判断一次.